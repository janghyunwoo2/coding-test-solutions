# [플랫폼] 문제 이름 / [난이도]

- **[문제 링크] **
- **날짜:** 2025.10.20
- **사용한 언어:** Python

## 🔍 문제 요약

> 여기에 문제를 나만의 언어로 간단하게 요약해서 적어봐.
(예: 주어진 배열에서 가장 작은 K개의 원소를 찾아 합을 반환하는 문제.)
> 

## 💡 핵심 아이디어 / 접근 방식

어떤 고민을 했고, 어떤 아이디어로 문제를 풀어나갔는지 단계별로 적어주는 게 좋아.

- 처음에는 어떤 방법으로 접근했는지
- 왜 그 방법이 틀렸는지 / 비효율적이었는지
- 최종적으로 어떤 아이디어를 사용했는지 (예: '투 포인터'를 사용하면 시간 복잡도를 O(N)으로 줄일 수 있다!)
- **(특히 중요한 부분!): 이 문제의 핵심 알고리즘이나 자료구조가 뭔지 명확하게 적기.**


1.  **문제 이해 및 분석**:
    *   목표: N개의 정수 중 최솟값과 최댓값 찾기.
    *   입력: N (1~100만), N개의 정수 (-100만~100만).
    *   출력: 최솟값과 최댓값을 공백 구분 출력.
    *   제한: 시간 1초, 메모리 256MB. N이 100만까지이므로 O(N) 또는 O(N log N) 알고리즘 필요.
    *   예외: N=1인 경우, 모든 수가 같거나 음수인 경우 고려.

2.  **알고리즘 설계**:
    *   **아이디어 1 (선택)**: Python의 `min()`과 `max()` 내장 함수를 활용하는 것이 가장 간결하고 효율적이라고 판단. 리스트 전체를 읽어 메모리에 저장 후 두 함수를 호출.
        *   시간 복잡도: `O(N)` (리스트 생성 + `min()/max()` 각 `O(N)`)
        *   공간 복잡도: `O(N)` (리스트에 모든 숫자 저장)
    *   **아이디어 2 (대안)**: 변수 두 개(`min_val`, `max_val`)를 초기화하고, 입력 숫자를 하나씩 읽으면서 두 변수를 갱신.
        *   시간 복잡도: `O(N)`
        *   공간 복잡도: `O(1)` (숫자를 스트림으로 처리할 경우)

3.  **코드 구현**:
    *   `sys.stdin.readline`을 사용하여 빠르게 입력 받음.
    *   `map(int, input_string.split())`으로 숫자들을 정수 리스트로 변환.
    *   `min()`과 `max()` 함수 적용 후 출력.

4.  **테스트 및 디버깅**:
    *   **예제 입력:** `5\n20 10 35 30 7` -> `7 35` (성공)
    *   **N=1 케이스:** `1\n100` -> `100 100` (성공)
    *   **음수 포함 케이스:** `4\n-10 0 5 -20` -> `-20 5` (성공)
    *   모든 테스트 케이스에서 정상 작동함을 확인.

5.  **최적화**:
    *   현재 Python `min()`/`max()` 함수는 내부적으로 C로 구현되어 매우 최적화되어 있으므로, 추가적인 시간 복잡도 최적화는 불필요하다고 판단.
    *   `O(1)` 공간 복잡도를 원한다면 `map` 객체를 순회하며 `min_val`, `max_val`을 갱신하는 방식을 고려할 수 있으나, 가독성과 파이썬의 특성을 고려하여 `min()/max()` 사용이 더 적합하다고 결론.